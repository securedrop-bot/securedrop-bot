// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package securedropbot

import (
	"context"
	"github.com/google/go-github/github"
	"sync"
)

var (
	lockissuesServiceMockCreateComment sync.RWMutex
	lockissuesServiceMockListComments  sync.RWMutex
)

// issuesServiceMock is a mock implementation of issuesService.
//
//     func TestSomethingThatUsesissuesService(t *testing.T) {
//
//         // make and configure a mocked issuesService
//         mockedissuesService := &issuesServiceMock{
//             CreateCommentFunc: func(in1 context.Context, in2 string, in3 string, in4 int, in5 *github.IssueComment) (*github.IssueComment, *github.Response, error) {
// 	               panic("TODO: mock out the CreateComment method")
//             },
//             ListCommentsFunc: func(in1 context.Context, in2 string, in3 string, in4 int, in5 *github.IssueListCommentsOptions) ([]*github.IssueComment, *github.Response, error) {
// 	               panic("TODO: mock out the ListComments method")
//             },
//         }
//
//         // TODO: use mockedissuesService in code that requires issuesService
//         //       and then make assertions.
//
//     }
type issuesServiceMock struct {
	// CreateCommentFunc mocks the CreateComment method.
	CreateCommentFunc func(in1 context.Context, in2 string, in3 string, in4 int, in5 *github.IssueComment) (*github.IssueComment, *github.Response, error)

	// ListCommentsFunc mocks the ListComments method.
	ListCommentsFunc func(in1 context.Context, in2 string, in3 string, in4 int, in5 *github.IssueListCommentsOptions) ([]*github.IssueComment, *github.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateComment holds details about calls to the CreateComment method.
		CreateComment []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 string
			// In3 is the in3 argument value.
			In3 string
			// In4 is the in4 argument value.
			In4 int
			// In5 is the in5 argument value.
			In5 *github.IssueComment
		}
		// ListComments holds details about calls to the ListComments method.
		ListComments []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 string
			// In3 is the in3 argument value.
			In3 string
			// In4 is the in4 argument value.
			In4 int
			// In5 is the in5 argument value.
			In5 *github.IssueListCommentsOptions
		}
	}
}

// CreateComment calls CreateCommentFunc.
func (mock *issuesServiceMock) CreateComment(in1 context.Context, in2 string, in3 string, in4 int, in5 *github.IssueComment) (*github.IssueComment, *github.Response, error) {
	if mock.CreateCommentFunc == nil {
		panic("moq: issuesServiceMock.CreateCommentFunc is nil but issuesService.CreateComment was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 string
		In3 string
		In4 int
		In5 *github.IssueComment
	}{
		In1: in1,
		In2: in2,
		In3: in3,
		In4: in4,
		In5: in5,
	}
	lockissuesServiceMockCreateComment.Lock()
	mock.calls.CreateComment = append(mock.calls.CreateComment, callInfo)
	lockissuesServiceMockCreateComment.Unlock()
	return mock.CreateCommentFunc(in1, in2, in3, in4, in5)
}

// CreateCommentCalls gets all the calls that were made to CreateComment.
// Check the length with:
//     len(mockedissuesService.CreateCommentCalls())
func (mock *issuesServiceMock) CreateCommentCalls() []struct {
	In1 context.Context
	In2 string
	In3 string
	In4 int
	In5 *github.IssueComment
} {
	var calls []struct {
		In1 context.Context
		In2 string
		In3 string
		In4 int
		In5 *github.IssueComment
	}
	lockissuesServiceMockCreateComment.RLock()
	calls = mock.calls.CreateComment
	lockissuesServiceMockCreateComment.RUnlock()
	return calls
}

// ListComments calls ListCommentsFunc.
func (mock *issuesServiceMock) ListComments(in1 context.Context, in2 string, in3 string, in4 int, in5 *github.IssueListCommentsOptions) ([]*github.IssueComment, *github.Response, error) {
	if mock.ListCommentsFunc == nil {
		panic("moq: issuesServiceMock.ListCommentsFunc is nil but issuesService.ListComments was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 string
		In3 string
		In4 int
		In5 *github.IssueListCommentsOptions
	}{
		In1: in1,
		In2: in2,
		In3: in3,
		In4: in4,
		In5: in5,
	}
	lockissuesServiceMockListComments.Lock()
	mock.calls.ListComments = append(mock.calls.ListComments, callInfo)
	lockissuesServiceMockListComments.Unlock()
	return mock.ListCommentsFunc(in1, in2, in3, in4, in5)
}

// ListCommentsCalls gets all the calls that were made to ListComments.
// Check the length with:
//     len(mockedissuesService.ListCommentsCalls())
func (mock *issuesServiceMock) ListCommentsCalls() []struct {
	In1 context.Context
	In2 string
	In3 string
	In4 int
	In5 *github.IssueListCommentsOptions
} {
	var calls []struct {
		In1 context.Context
		In2 string
		In3 string
		In4 int
		In5 *github.IssueListCommentsOptions
	}
	lockissuesServiceMockListComments.RLock()
	calls = mock.calls.ListComments
	lockissuesServiceMockListComments.RUnlock()
	return calls
}
